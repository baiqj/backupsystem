#!/usr/bin/env python

import sys, os, os.path, traceback
import getopt, datetime
import hashlib, base64

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), 'utils'))
import colorful

def help():
	msg = """Scripts used for query backup data generated by "sftp module"
%s: bkdb subcmd [data_idx] [datetime_range] [--nocolor]
%s:
	ls                  =>  list backup datas
	rm                  =>  remove backup datas
	verify              =>  whether the datas are vaild
	export <destdir>    =>  export backup datas

%s: i1,i2,i3,...
%s:
	>datetime, nr_of_records
	<datetime, nr_of_records
	>datetime_start, <datetime_end
	=datetime
%s:
	2009-10-20 09:16:55
""" % tuple(map(lambda x: colorful.colorize('INFORM', x), ('Usage', 'Subcmd', 'data_idx', 'datetime_range', 'datetime')))
	print msg

class DataNameSyntaxError(Exception):
	pass

class InvaildDataSourceIndex(Exception):
	pass

class DatetimeSyntaxError(Exception):
	pass

class DatetimeRangeSyntaxError(Exception):
	pass
	
def datetime_from_filestring(dt):
	fields = dt.split('-')
	fields = fields[:-1] + fields[-1].split('_')
	try:
		year, month, day, hour, minute, second = map(lambda x: int(x, 10), fields)
		year += 2000
	except IndexError:
		raise DataNameSyntaxError, 'Not enough datetime sub-fields "%s"' % dt
	except ValueError:
		raise DataNameSyntaxError, 'Bad datetime representation "%s"' % dt
	
	try:
		return datetime.datetime(year, month, day, hour, minute, second)
	except ValueError:
		raise DataNameSyntaxError, 'Invalid datetime field "%s"' % dt

def copy_file(src_p, dest_p):
	src_f = open(src_p, 'rb')
	dest_f = open(dest_p, 'wb')
	
	blk_size = 512 * 1024
	blk = src_f.read(blk_size)
	while blk:
		dest_f.write(blk)
		blk = src_f.read(blk_size)
	
def check_data(path, expected):
	ret = False
	
	h= hashlib.sha256()
	
	dat = open(path, 'rb')
	
	blk_size = 512 * 1024
	blk = dat.read(blk_size)
	while blk:
		h.update(blk)
		blk = dat.read(blk_size)
	
	if expected == h.hexdigest():
		ret = True
	
	return ret

def try_decode_dn(name):
	try:
		ret = base64.urlsafe_b64decode(name)
	except TypeError:
		ret = name
	
	return ret

def filter_by_datetime_range_spec(db, dr):
	# the records are in descending order
	def oneshot(a_db, r1, r2):
		_db = filter(lambda x: x[2] == r1, a_db)
		if len(_db) > 1:
			print colorful.colorize('red', 'May have corrupted data:')
			for record in _db:
				print '\t%s\n' % record[0]
		
		return _db

	
	def lt(a_db, r1, r2):
		if r2 == None:
			# give a very big number
			r2 = 1 << 32
		
		i = 0
		while i < len(a_db):
			record = a_db[i]
			if record[2] < r1:
				break
			i += 1

		return a_db[i:i + r2]


	def gt(a_db, r1, r2):
		if r2 == None:
			# give a very big number
			r2 = 1 << 32

		i = len(a_db) - 1
		while i >= 0:
			record = a_db[i]
			if record[2] > r1:
				break
			i -= 1
		
		_db = a_db[:i + 1]
		_db.reverse()
		
		return _db[:r2]


	def span(a_db, r1, r2):
		start = end = 0
		
		while start < len(a_db):
			if a_db[start][2] < r2:
				end = start
				while end < len(a_db):
					if a_db[end][2] <= r1:
						break
					end += 1
				break
			start += 1

		return a_db[start:end]


	if dr:
		op_, range_ = dr
		r1, r2 = range_

		ops = {
			'=': oneshot,
			'>': gt,
			'<': lt,
			'<>': span,
		}
		
		_db = {}
		for k in db:
			_db[k] = ops[op_](db[k], r1, r2)

	return _db


def datetime_from_userstring(dt):
	today = datetime.datetime.today()
	year, month, day, hour, minute, second = today.year, today.month, None, 0, 0, 0
	
	try:
		d, t = dt.split(' ')
	except ValueError:
		d, t = dt, None
	df = d.split('-')
	
	if len(df) == 3:
		year, month, day = df
	elif len(df) == 2:
		month, day = df
	elif len(df) == 1:
		day = df[0]
	else:
		raise DatetimeSyntaxError, 'Too many date sub-fields "%s"' % dt
	
	if t:
		tf = t.split(':')
		if len(tf) == 3:
			hour, minute, second = tf
		elif len(tf) == 2:
			hour, minute = tf
		elif len(tf) == 1:
			hour = tf[0]
		else:
			raise DatetimeSyntaxError, 'Too many time sub-fields "%s"' % dt
	
	try:
		year, month, day, hour, minute, second = map(lambda x: type(x) == str and int(x, 10) or x, (year, month, day, hour, minute, second))
		return datetime.datetime (year, month, day, hour, minute, second)
	except ValueError:
		raise DatetimeSyntaxError, 'Bad datetime description string "%s"' % dt


def parse_datetime_range_spec(drs):
	op_ = None
	range_ = [None, None]

	parts = drs.split(',')
	parts = map(str.strip, parts)
	try:
		if len(parts) == 2:
			p1, p2 = parts
			op1 = p1[0]
		
			if op1 in ('<', '>'):
				if p2[0] in ('<', '>'):
					op2 = p2[0]
					
					op_ = '<>'
					dt1 = datetime_from_userstring(p1[1:].strip ())
					dt2 = datetime_from_userstring(p2[1:].strip ())
					
					if op1 == op2:
						raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
					elif op1 == '>': # >dt1, <dt2
						if dt1 >= dt2:
							raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"(BadRange)' % drs
						range_ = [dt1, dt2]	
					else: # <dt1, >dt2
						if dt1 <= dt2:
							raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"(BadRange)' % drs
						range_ = [dt2, dt1]
				elif p2.isdigit():
					op_ = op1
					
					try:
						counter = int(p2)
					except ValueError:
						raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
					dt = datetime_from_userstring(p1[1:].strip())
					range_ = [dt, counter]
				else:
					raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
			else:
				raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
		
		elif len(parts) == 1:
			p = parts[0]
			op1 = p[0]
			
			if op1 in ('=', '>', '<'):
				op_ = op1
				dt = datetime_from_userstring(p[1:].strip())
				range_ = [dt, None]
			else:
				raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
		else:
			raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
	except DatetimeSyntaxError:
		t, v, tb = sys.exc_info()
		raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"\n\t=> %s' % (drs, v)
	except:
		raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
	
	return (op_, range_)

	
class bkdb(object):
	def __init__(self, dbpath):
		# get lock first ?
		self.dbpath = dbpath
	
	def _load(self):
		dirpath, dirnames, filenames = os.walk(self.dbpath).next()
		
		_db = {}
		for f in filenames:
			try:
				try:
					# name datetime hashsum
					n, d, h = f.split(' ')
				except ValueError:
					raise DataNameSyntaxError, 'Unexpected number of fields'
			
				dt = datetime_from_filestring(d)
			
				a_db = _db.get(n, [])
			
				# is the file a symbol link
				link_target = None
				filepath = os.path.join(dirpath, f)
				if os.path.islink(filepath):
					link_target = ''
					if not os.path.exists(filepath):
						link_target = '!'
					
					link_target += os.path.basename(os.readlink(filepath))
				 
				a_db.append((f, n, dt, h, link_target))
				_db[n] = a_db
			
			except DataNameSyntaxError:
				t, v, tb = sys.exc_info()
				print >>sys.stderr, 'Ignore "%s": %s' % (f, v)
		
		# descending order
		for src in _db:
			_db[src].sort(lambda x,y: x[2] > y[2] and -1 or y[2] > x[2] and 1 or 0)
		
		# map <source of each db> to <index number>
		sorted_src_index = _db.keys()
		sorted_src_index.sort()
		
		self.db = _db
		self.src_lookuptable = sorted_src_index
		
	def select(self, idx, dr):
		if not hasattr(self, 'db'):
			self._load()
		_db = self.db
		src_lookuptable = self.src_lookuptable
		
		ret = {}
		
		if idx == None:
			_idx = xrange(len(src_lookuptable))
		elif isinstance(idx, int):
			_idx = (idx,)
		elif hasattr(idx, '__iter__'):
			_idx = idx
		else:
			raise ValueError, 'select method only accept int or int seq as its first argument'

		try:
			for i in _idx:
				n = src_lookuptable[i]
				ret[n] = _db[n]
		except IndexError:
			raise InvaildDataSourceIndex, 'Bad data source index: %d' % idx
		
		if dr:
			ret =  filter_by_datetime_range_spec(ret, dr)
		
		return ret
	
	def listview(self, idx, dr):
		to_list = self.select(idx, dr)
		src_lookuptable = self.src_lookuptable
		dbpath = self.dbpath
		
		datefmt = '%Y-%m-%d %H:%M:%S'
		screen_nr_cols = 3
		col_width = len(datetime.datetime(2009, 10, 15, 18, 32, 18).strftime(datefmt).decode('utf8'))
		
		# format title
		for idx in xrange(len(src_lookuptable)):
			src = src_lookuptable[idx]
			print '%s %s %s'% (colorful.colorize('INFORM', '*'), colorful.colorize('bold', '[%d]' % idx), try_decode_dn(src))
		
		for idx in xrange(len(src_lookuptable)):
			src = src_lookuptable[idx]
			
			if not to_list.has_key(src):
				continue

			print '[%s] %s:' %(colorful.colorize('INFORM', str(idx)), try_decode_dn(src))

			# reorganize to cols
			a_db = to_list[src]
			nr_lines_one_col = (len(a_db) + (screen_nr_cols - 1)) / screen_nr_cols
			cols = []
			
			i = 0
			while i < len(a_db):
				if i % nr_lines_one_col == 0:
					cols.append([])
				cols[-1].append(a_db[i])
				i += 1
			
			if not cols: continue
			# do the print, red -> broken link, dim -> not key data
			for row in map(lambda *x: x, *cols):
				line_buf = []
				for f in row:
					if f:
						dt_str = f[2].strftime(datefmt)
						filepath = os.path.join(dbpath, f[0])
						link_target = f[4]
						if link_target:
							if link_target.startswith('!'):							
								line_buf.append(colorful.colorize('red', '%s [%d]' % (dt_str, idx)))
							else:
								line_buf.append(colorful.colorize('faint', '%s [%d]' % (dt_str, idx)))
						else:
							line_buf.append(colorful.colorize('bold', '%s [%d]' % (dt_str, idx)))
					# else -> last cell in last column

				print '\t%s' % '\t\t'.join(line_buf)
			print
	
	def verify(self, idx, dr):
		to_verify = self.select(idx, dr)
		dbpath = self.dbpath

		for src in to_verify:
			a_db = to_verify[src]
			for record in a_db:
				f = record[0]
				h = record[3]
				link_target = record[4]
				
				filepath = os.path.join(dbpath, f)
				if not check_data(filepath, h):
					if link_target:
						fmt = colorful.colorize('faint', f)
					else:
						fmt = colorful.colorize('bold', f)
					print '%sCorrupted data "%s"' % (colorful.colorize('red', '!!!'), fmt)
	
	def remove(self, idx, dr):
		to_remove = self.select(idx, dr)
		dbpath = self.dbpath
		_db = self.db
	
		for src in to_remove:
			a_db = to_remove[src]
			
			delayed = []
			removed = []
			
			for record in a_db:
				link_target = record[4]
				f = record[0]
				if link_target:
					filepath = os.path.join(dbpath, f)
					print 'Removing "%s"' % colorful.colorize('faint', f)
					os.remove(filepath)
					removed.append(f)
				else:
					delayed.append(f)

			a_db = _db[src]
			i = len(a_db) - 1
			while i >= 0:
				link_target = a_db[i][4]
				f = a_db[i][0]
				
				if f in removed or f in delayed:
					del a_db[i]
				elif link_target and link_target in delayed:
					print 'Removing "%s" (-> "%s")' % (colorful.colorize('bold', link_target), f) 
					os.rename(os.path.join(dbpath, link_target), os.path.join(dbpath, f))
					del delayed[delayed.index(link_target)]
					a_db[i] = a_db[i][:3] + (None, )
				i -= 1
			
			for f in delayed:
				filepath = os.path.join(dbpath, f)
				print 'Removing "%s"' % colorful.colorize('bold', f)
				os.remove(filepath)
	
	def export(self, idx, ds, destdir):
		to_export = self.select(idx, dr)
		dbpath = self.dbpath
	
		if not os.path.exists(destdir):
			os.makedirs(destdir)
	
		for src in to_export:
			a_db = to_export[src]
			for record in a_db:
				f = record[0]
				h = record[3]
				link_target = record[4]
				
				if link_target:
						fmt = colorful.colorize('faint', f)
				else:
					fmt = colorful.colorize('bold', f)
				
				filepath = os.path.join(dbpath, f)
				destpath = os.path.join(destdir, f)
				
				if check_data(filepath, record[3]):
					print 'Exporting "%s"' % fmt
					copy_file(filepath, destpath)
				else:
					print '%sCorrupted data "%s"' % (colorful.colorize('red', '!!!'), fmt)

def do_ls(idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)

	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.listview(idx, dr)
	
def do_rm(idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.remove(idx, dr)

def do_verify(idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.verify(idx, dr)

def do_export(destdir, idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.export(idx, dr, destdir)


if __name__ == '__main__':
	try:
		opts, rest = getopt.gnu_getopt(sys.argv[1:], "h", ["help", "nocolor"])
		opts = [o[0] for o in opts]
		if '-h' in opts or '--help' in opts:
			help()
			sys.exit(0)
		if '--nocolor' in opts:
			colorful.havecolor = False
			
	except getopt.GetoptError, err:
		sys.exit(str(err))
	
	try:
		subcmd = rest[0]
	except IndexError:
		help()
		sys.exit(0)
	rest = rest[1:]
	
	left_args_len = len(rest)
	rest_args_start = 0

	do_what = {
		'ls': do_ls,
		'rm': do_rm,
		'verify': do_verify,
		'export': do_export
	};
	
	if subcmd in do_what:
		try:
			args = []
		
			if subcmd == 'export':
				try:
					args.append(rest[rest_args_start])
				except IndexError:
					print >>sys.stderr, 'No destdir args!!!'
					sys.exit(-1)
				rest_args_start += 1
				left_args_len -= 1

			idx = dr = None
			if left_args_len > 2: left_args_len = 2
			while left_args_len > 0:
				_a = rest[rest_args_start]
				if _a.startswith(('>', '<', '=')):
					dr = parse_datetime_range_spec(_a)
				else:
					try:
						idx = map(int, _a.split(','))
					except ValueError:
						raise InvaildDataSourceIndex, 'Invalid data source index "%s"' % _a
				rest_args_start += 1
				left_args_len -= 1
			args.extend((idx, dr))
			
			# do the real job
			do_what[subcmd](*args)
		except KeyboardInterrupt:
			print 'bye'
		except:
			t, v, tb = sys.exc_info()
			print >>sys.stderr, '%s (%s)' % (v, t)
			traceback.print_tb(tb, file=sys.stderr)
			sys.exit(-1)
	else:
		print >>sys.stderr, 'Unknown sub-command %s' % subcmd
		sys.exit(-1)

