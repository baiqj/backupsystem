#!/usr/bin/env python

import sys, os, os.path, traceback
import getopt, datetime
import hashlib, base64

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), 'utils'))
import colorful

def help():
	msg = """Scripts used for query backup data generated by "sftp module"
%s: bkdb subcmd  [--nocolor]
%s:
	ls              [data_idx] [datetime_range] =>  list backup datas
	rm              [data_idx] [datetime_range] =>  remove backup datas
	verify          [data_idx] [datetime_range] =>  whether the datas are vaild
	export <destdir>  [data_idx] [datetime_range] =>  export backup datas
	clean           =>  clean unreferenced datachunk
	clean-pretend   =>  like "clean", but not take real actions
	build           =>  in-place build backup db by exported data

%s: i1,i2,i3,...
%s:
	>datetime, nr_of_records
	<datetime, nr_of_records
	>datetime_start, <datetime_end
	=datetime
%s:
	2009-10-20 09:16:55
""" % tuple(map(lambda x: colorful.colorize('INFORM', x), ('Usage', 'Subcmd', 'data_idx', 'datetime_range', 'datetime')))
	print msg

class BadDataEntry(Exception):
	pass

class DataNameSyntaxError(Exception):
	pass

class InvaildDataSourceIndex(Exception):
	pass

class DatetimeSyntaxError(Exception):
	pass

class DatetimeRangeSyntaxError(Exception):
	pass
	
def datetime_from_filestring(dt):
	fields = dt.split('-')
	fields = fields[:-1] + fields[-1].split('_')
	try:
		year, month, day, hour, minute, second = map(lambda x: int(x, 10), fields)
		year += 2000
	except IndexError:
		raise DataNameSyntaxError, 'Not enough datetime sub-fields "%s"' % dt
	except ValueError:
		raise DataNameSyntaxError, 'Bad datetime representation "%s"' % dt
	
	try:
		return datetime.datetime(year, month, day, hour, minute, second)
	except ValueError:
		raise DataNameSyntaxError, 'Invalid datetime field "%s"' % dt

def copy_file(src_p, dest_p):
	src_f = open(src_p, 'rb')
	dest_f = open(dest_p, 'wb')
	
	blk_size = 512 * 1024
	blk = src_f.read(blk_size)
	while blk:
		dest_f.write(blk)
		blk = src_f.read(blk_size)
	
def check_data(path, expected):
	ret = False
	
	h= hashlib.sha256()
	
	dat = open(path, 'rb')
	
	blk_size = 512 * 1024
	blk = dat.read(blk_size)
	while blk:
		h.update(blk)
		blk = dat.read(blk_size)
	
	if expected == h.hexdigest():
		ret = True
	
	return ret

def try_decode_dn(name):
	try:
		ret = base64.urlsafe_b64decode(name)
	except TypeError:
		ret = name
	
	return ret

def filter_by_datetime_range_spec(db, dr):
	# the records are in descending order
	def oneshot(a_db, r1, r2):
		_db = filter(lambda x: x[2] == r1, a_db)
		if len(_db) > 1:
			print colorful.colorize('red', 'May have corrupted data:')
			for record in _db:
				print '\t%s\n' % record[0]
		
		return _db

	
	def lt(a_db, r1, r2):
		if r2 == None:
			# give a very big number
			r2 = 1 << 32
		
		i = 0
		while i < len(a_db):
			record = a_db[i]
			if record[2] < r1:
				break
			i += 1

		return a_db[i:i + r2]


	def gt(a_db, r1, r2):
		if r2 == None:
			# give a very big number
			r2 = 1 << 32

		i = len(a_db) - 1
		while i >= 0:
			record = a_db[i]
			if record[2] > r1:
				break
			i -= 1
		
		_db = a_db[:i + 1]
		_db.reverse()
		
		return _db[:r2]


	def span(a_db, r1, r2):
		start = end = 0
		
		while start < len(a_db):
			if a_db[start][2] < r2:
				end = start
				while end < len(a_db):
					if a_db[end][2] <= r1:
						break
					end += 1
				break
			start += 1

		return a_db[start:end]


	if dr:
		op_, range_ = dr
		r1, r2 = range_

		ops = {
			'=': oneshot,
			'>': gt,
			'<': lt,
			'<>': span,
		}
		
		_db = {}
		for k in db:
			_db[k] = ops[op_](db[k], r1, r2)

	return _db


def datetime_from_userstring(dt):
	today = datetime.datetime.today()
	year, month, day, hour, minute, second = today.year, today.month, None, 0, 0, 0
	
	try:
		d, t = dt.split(' ')
	except ValueError:
		d, t = dt, None
	df = d.split('-')
	
	if len(df) == 3:
		year, month, day = df
	elif len(df) == 2:
		month, day = df
	elif len(df) == 1:
		day = df[0]
	else:
		raise DatetimeSyntaxError, 'Too many date sub-fields "%s"' % dt
	
	if t:
		tf = t.split(':')
		if len(tf) == 3:
			hour, minute, second = tf
		elif len(tf) == 2:
			hour, minute = tf
		elif len(tf) == 1:
			hour = tf[0]
		else:
			raise DatetimeSyntaxError, 'Too many time sub-fields "%s"' % dt
	
	try:
		year, month, day, hour, minute, second = map(lambda x: type(x) == str and int(x, 10) or x, (year, month, day, hour, minute, second))
		return datetime.datetime (year, month, day, hour, minute, second)
	except ValueError:
		raise DatetimeSyntaxError, 'Bad datetime description string "%s"' % dt


def parse_datetime_range_spec(drs):
	op_ = None
	range_ = [None, None]

	parts = drs.split(',')
	parts = map(str.strip, parts)
	try:
		if len(parts) == 2:
			p1, p2 = parts
			op1 = p1[0]
		
			if op1 in ('<', '>'):
				if p2[0] in ('<', '>'):
					op2 = p2[0]
					
					op_ = '<>'
					dt1 = datetime_from_userstring(p1[1:].strip ())
					dt2 = datetime_from_userstring(p2[1:].strip ())
					
					if op1 == op2:
						raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
					elif op1 == '>': # >dt1, <dt2
						if dt1 >= dt2:
							raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"(BadRange)' % drs
						range_ = [dt1, dt2]	
					else: # <dt1, >dt2
						if dt1 <= dt2:
							raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"(BadRange)' % drs
						range_ = [dt2, dt1]
				elif p2.isdigit():
					op_ = op1
					
					try:
						counter = int(p2)
					except ValueError:
						raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
					dt = datetime_from_userstring(p1[1:].strip())
					range_ = [dt, counter]
				else:
					raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
			else:
				raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
		
		elif len(parts) == 1:
			p = parts[0]
			op1 = p[0]
			
			if op1 in ('=', '>', '<'):
				op_ = op1
				dt = datetime_from_userstring(p[1:].strip())
				range_ = [dt, None]
			else:
				raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
		else:
			raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
	except DatetimeSyntaxError:
		t, v, tb = sys.exc_info()
		raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"\n\t=> %s' % (drs, v)
	except:
		raise DatetimeRangeSyntaxError, 'Bad datetime range spec "%s"' % drs
	
	return (op_, range_)

	
class bkdb(object):
	obj_prefix = '@obj_'

	def __init__(self, dbpath):
		self.dbpath = dbpath
	
	def _load(self):
		dbpath = self.dbpath
		obj_prefix = self.obj_prefix

		dirpath, dirnames, filenames = os.walk(dbpath).next()

		_db = {}
		_objs = {}
		for f in filenames:
			if f.startswith(obj_prefix): # is a object (datachunk)
				refcnt = _objs.get(f, 0)
				assert refcnt <= 0
				_objs[f] = -refcnt

			elif not f.endswith('.tmp'): # is a data entry
				try:
					try:
						# name datetime hashsum
						n, d, h = f.split(' ')
					except ValueError:
						raise DataNameSyntaxError, 'Unexpected number of fields'
			
					dt = datetime_from_filestring(d)
				
					# whether the data entry is good ?
					#   -> link to datachunk "dbpath/<obj_prefix + hash>" or
					#   -> not a link
					filepath = os.path.join(dbpath, f)
				
					if os.path.islink(filepath):
						link_target = os.readlink(filepath)
						obj = obj_prefix + h
						objpath = os.path.join(dbpath, obj)
				
						if os.path.abspath(link_target) != os.path.abspath(objpath):
							raise BadDataEntry, 'Links to "%s", not datachunk "%s"' % (link_target, obj)
						# calculate reference count of the objects
						if not _objs.has_key(obj):
							ref_cnt = -1
						else:
							ref_cnt = _objs[obj]
							ref_cnt = ref_cnt >= 0 and ref_cnt + 1 or ref_cnt - 1
						_objs[obj] = ref_cnt

					# read, modify, store
					a_db = _db.get(n, [])			 
					a_db.append((f, n, dt, h))
					_db[n] = a_db
			
				except (DataNameSyntaxError, BadDataEntry):
					t, v, tb = sys.exc_info()
					print >>sys.stderr, 'Ignore "%s": %s' % (f, v)
		
		# descending order
		for src in _db:
			a_db = _db[src]
			a_db.sort(lambda x,y: x[2] > y[2] and -1 or y[2] > x[2] and 1 or 0)

			# add "whether diff from last record" field
			last_hashval = None
			for i in xrange(len(a_db) - 1, -1, -1):
				record = a_db[i]
				h = record[3]
				
				a_db[i] = record + (h != last_hashval,)
				
				last_hashval = h
		
		# map <source of each db> to <index number>
		sorted_src_index = _db.keys()
		sorted_src_index.sort()
		
		self.db = _db
		self.objs = _objs
		self.src_lookuptable = sorted_src_index
		
	def select(self, idx, dr):
		if not hasattr(self, 'db'):
			self._load()
		_db = self.db
		src_lookuptable = self.src_lookuptable
		
		ret = {}
		
		if idx == None:
			_idx = xrange(len(src_lookuptable))
		elif isinstance(idx, int):
			_idx = (idx,)
		elif hasattr(idx, '__iter__'):
			_idx = idx
		else:
			raise ValueError, 'select method only accept int or int seq as its first argument'

		try:
			for i in _idx:
				n = src_lookuptable[i]
				ret[n] = _db[n]
		except IndexError:
			raise InvaildDataSourceIndex, 'Bad data source index: %d' % idx
		
		if dr:
			ret =  filter_by_datetime_range_spec(ret, dr)
		
		return ret
	
	def listview(self, idx, dr):
		to_list = self.select(idx, dr)
		src_lookuptable = self.src_lookuptable
		dbpath = self.dbpath
		
		datefmt = '%Y-%m-%d %H:%M:%S'
		screen_nr_cols = 3
		col_width = len(datetime.datetime(2009, 10, 15, 18, 32, 18).strftime(datefmt).decode('utf8'))
		
		# format title
		for idx in xrange(len(src_lookuptable)):
			src = src_lookuptable[idx]
			print '%s %s %s'% (colorful.colorize('INFORM', '*'), colorful.colorize('bold', '[%d]' % idx), try_decode_dn(src))
		
		for idx in xrange(len(src_lookuptable)):
			src = src_lookuptable[idx]
			
			if not to_list.has_key(src):
				continue

			print '[%s] %s:' %(colorful.colorize('INFORM', str(idx)), try_decode_dn(src))

			# reorganize to cols
			a_db = to_list[src]
			nr_lines_one_col = (len(a_db) + (screen_nr_cols - 1)) / screen_nr_cols
			cols = []

			for i in xrange(len(a_db)):
				if i % nr_lines_one_col == 0:
					cols.append([])

				cols[-1].append(a_db[i])
			
			if not cols: continue
			# do the print, red -> broken link, dim -> not key data
			for row in map(lambda *x: x, *cols):
				line_buf = []
				for cell in row:
					if cell:
						f = cell[0]
						dt = cell[2]
						has_change = cell[4]
						
						dt_str = dt.strftime(datefmt)
						filepath = os.path.join(dbpath, f)

						if not os.path.exists(filepath):					
							line_buf.append(colorful.colorize('red', '%s [%d]' % (dt_str, idx)))
						else:
							if not has_change:
								line_buf.append(colorful.colorize('faint', '%s [%d]' % (dt_str, idx)))
							else:
								line_buf.append(colorful.colorize('bold', '%s [%d]' % (dt_str, idx)))
					# else -> last cell in last column

				print '\t%s' % '\t\t'.join(line_buf)
			print

	def verify(self, idx, dr):
		to_verify = self.select(idx, dr)
		dbpath = self.dbpath

		for src in to_verify:
			a_db = to_verify[src]
			for record in a_db:
				f = record[0]
				h = record[3]
				has_change = record[4]
				
				filepath = os.path.join(dbpath, f)
				if os.path.exists(filepath):
					if not check_data(filepath, h):
						if not has_change:
							fmt = colorful.colorize('faint', f)
						else:
							fmt = colorful.colorize('bold', f)
						print '%sCorrupted data "%s"' % (colorful.colorize('red', '!!!'), fmt)
				else:
					fmt = colorful.colorize('red', f)
					print '%sBad link "%s"' % (colorful.colorize('red', '!!!'), fmt)

	def clean(self, pretend = False):
		if not hasattr(self, 'db'):
			self._load()

		_objs = self.objs
		dbpath = self.dbpath

		print '%s unreferenced datachunk...' % (pretend and 'Scanning' or 'Removing'),
		nr_cols = 1
		nr_non_ref_objs = 0
		for o in _objs:
			ref_cnt = _objs[o]
			if ref_cnt == 0:
				if not nr_non_ref_objs % nr_cols:
					print
				
				print '\t' + o,
				nr_non_ref_objs += 1
				
				if not pretend:
					objpath = os.path.join(dbpath, o)
					os.remove(objpath)
		print
		print 'Total %d unreferenced datachunk %s' % (nr_non_ref_objs, pretend and 'Detected' or 'Removed')
		
		# trigger reload
		del self.db	

	def build(self):
		"Build db through exported data inplace"
		if not hasattr(self, 'db'):
			self._load()
		
		obj_prefix = self.obj_prefix
		dbpath = self.dbpath
		_db = self.db
		_objs = self.objs

		for src in _db:
			a_db = _db[src]
			
			for record in a_db:
				f = record[0]
				h = record[3]
				has_change = record[4]

				filepath = os.path.join(dbpath, f)

				if not os.path.islink(filepath):
					if not has_change:
						fmt = colorful.colorize('faint', f)
					else:
						fmt = colorful.colorize('bold', f)

					if check_data(filepath, h):
						obj = obj_prefix + h
						objpath = os.path.join(dbpath, obj)

						# create a temporarily link to object
						try:
							tmplink = filepath + '.tmp'
							os.symlink(obj, tmplink)
						except OSError, err:
							print >>sys.stderr, 'Ignore: failed to create temporarily link, when process "%s"' %f
							print '\t->%s' % str(err)

						gen_new_obj_reason = None
						if obj not in _objs:
							gen_new_obj_reason = 'Generate datachunk "%s"' % obj
						elif _objs[obj] < 0:
							gen_new_obj_reason = 'Generate non-exists but referenced datachunk "%s"' % obj
						elif not check_data(objpath, h):
							gen_new_obj_reason = 'Replace old invaild datachunk "%s"' %obj
							
						if gen_new_obj_reason:
							print '%s%s' % (colorful.colorize('INFORM', '*'), gen_new_obj_reason)
							os.rename(filepath, objpath)
						else:
							os.remove(filepath)
							
						os.rename(tmplink, filepath)

						refcnt = _objs.get(obj, 0)
						_objs[obj] = abs(refcnt) + 1
					else:
						print '%sCorrupted data "%s"' % (colorful.colorize('red', '!!!'), fmt)

	def remove(self, idx, dr):
		to_remove = self.select(idx, dr)
		dbpath = self.dbpath
		_db = self.db
		obj_prefix = self.obj_prefix
		_objs = self.objs
	
		objs_to_remove = []
		for src in to_remove:
			a_db = to_remove[src]
			
			for record in a_db:
				f = record[0]
				h = record[3]

				filepath = os.path.join(dbpath, f)
				
				need_gc = os.path.islink(filepath)
				print 'Removing "%s"' % f
				os.remove(filepath)
				
				# gc
				if need_gc:
					obj = obj_prefix + h
					ref_cnt = _objs[obj]

					if ref_cnt == 1:
						objs_to_remove.append(obj)
						_objs[obj] = 0
					elif ref_cnt == -1:
						del _objs[obj]
					else:
						assert ref_cnt != 0
						_objs[obj] = ref_cnt > 0 and ref_cnt -1 or ref_cnt + 1


		# gc: do the real job
		print 'Removing now non-referenced datachunk...',
		nr_cols = 1
		for i in xrange(len(objs_to_remove)):
			obj = objs_to_remove[i]
			objpath = os.path.join(dbpath, obj)
			
			if not i % nr_cols:
				print

			print '\t' + obj,
			os.remove(objpath)
		print

		# trigger reload
		del self.db
	
	def export(self, idx, ds, destdir):
		to_export = self.select(idx, dr)
		dbpath = self.dbpath
	
		if not os.path.exists(destdir):
			os.makedirs(destdir)
	
		for src in to_export:
			a_db = to_export[src]
			for record in a_db:
				f = record[0]
				h = record[3]
				has_change = record[4]
				
				filepath = os.path.join(dbpath, f)
				destpath = os.path.join(destdir, f)
				
				if os.path.exists(filepath):
					if not has_change:
						fmt = colorful.colorize('faint', f)
					else:
						fmt = colorful.colorize('bold', f)

					if check_data(filepath, record[3]):
						print 'Exporting "%s"' % fmt
						copy_file(filepath, destpath)
					else:
						print '%sCorrupted data "%s"' % (colorful.colorize('red', '!!!'), fmt)
				else:
					fmt = colorful.colorize('red', f)
					print '%sBad link "%s"' % (colorful.colorize('red', '!!!'), fmt)

def do_ls(idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)

	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.listview(idx, dr)
	
def do_rm(idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.remove(idx, dr)

def do_verify(idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.verify(idx, dr)

def do_export(destdir, idx, dr):
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.export(idx, dr, destdir)

def do_clean():
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.clean()
	
def do_clean_pretend():
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.clean(pretend = True)
	
def do_build():
	dbpath = os.path.abspath('.')
	cur_db = bkdb(dbpath)
	
	print colorful.colorize('INFORM', 'Base path') +  ': "%s"' % dbpath
	cur_db.build()
	
	
if __name__ == '__main__':
	try:
		opts, rest = getopt.gnu_getopt(sys.argv[1:], "h", ["help", "nocolor"])
		opts = [o[0] for o in opts]
		if '-h' in opts or '--help' in opts:
			help()
			sys.exit(0)
		if '--nocolor' in opts:
			colorful.havecolor = False
			
	except getopt.GetoptError, err:
		sys.exit(str(err))
	
	try:
		subcmd = rest[0]
	except IndexError:
		help()
		sys.exit(0)
	rest = rest[1:]
	
	left_args_len = len(rest)
	rest_args_start = 0

	do_what = {
		'ls': do_ls,
		'rm': do_rm,
		'verify': do_verify,
		'export': do_export,
		'clean': do_clean,
		'clean-pretend': do_clean_pretend,
		'build': do_build
	};
	
	if subcmd in do_what:
		try:
			args = []
			
			if subcmd in ('ls', 'rm', 'verify', 'export'):
				if subcmd == 'export':
					try:
						args.append(rest[rest_args_start])
					except IndexError:
						print >>sys.stderr, 'No destdir args!!!'
						sys.exit(-1)
					rest_args_start += 1
					left_args_len -= 1

				idx = dr = None
				if left_args_len > 2: left_args_len = 2
				while left_args_len > 0:
					_a = rest[rest_args_start]
					if _a.startswith(('>', '<', '=')):
						dr = parse_datetime_range_spec(_a)
					else:
						try:
							idx = map(int, _a.split(','))
						except ValueError:
							raise InvaildDataSourceIndex, 'Invalid data source index "%s"' % _a
					rest_args_start += 1
					left_args_len -= 1
				args.extend((idx, dr))

			# do the real job
			do_what[subcmd](*args)
		except KeyboardInterrupt:
			print 'bye'
		except:
			t, v, tb = sys.exc_info()
			print >>sys.stderr, '%s (%s)' % (v, t)
			traceback.print_tb(tb, file=sys.stderr)
			sys.exit(-1)
	else:
		print >>sys.stderr, 'Unknown sub-command %s' % subcmd
		sys.exit(-1)

